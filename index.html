<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SharkScope — Shark Habitat Support (Demo, Mock Only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Chart.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <!-- TopoJSON (for land mask) -->
  <script defer src="https://unpkg.com/topojson-client@3"></script>
  <!-- html2canvas for export -->
  <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <style>
    :root{
      --bg:#0A192F; --panel:#0F2547; --fg:#E6EDF3; --muted:#9AA4AE; --border:#1C325A;
      --accent:#3BA3FF; --good:#2ECC71; --mid:#F1C40F; --bad:#E74C3C; --focus:#86B7FE;
      --violet:#9b6cff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}
    a{color:#8bc1ff}
    .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header{display:flex;align-items:center;gap:12px;padding:10px 14px;border-bottom:1px solid var(--border);position:sticky;top:0;background:rgba(10,25,47,.9);backdrop-filter:saturate(120%) blur(4px);z-index:10}
    .brand{font-weight:700;letter-spacing:.3px}
    .pill{border:1px solid var(--border);padding:2px 8px;border-radius:999px;font-size:12px;color:var(--muted)}
    .grow{flex:1}
    .toolbar{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid var(--border);color:var(--fg);padding:6px 10px;border-radius:8px;cursor:pointer}
    .btn:hover{border-color:#2b4b86}
    .btn-primary{background:#1b3a6a;border-color:#1b3a6a}
    .btn-primary:hover{background:#234a86}
    .btn-toggle[aria-pressed="true"]{background:#18335f;border-color:#2b4b86}
    .seg{display:inline-flex;border:1px solid var(--border);border-radius:10px;overflow:hidden}
    .seg button{border:0;padding:6px 10px;background:transparent;color:var(--fg);cursor:pointer}
    .seg button[aria-pressed="true"]{background:#16315a}
    .kbd{border:1px solid var(--border);border-bottom-width:2px;border-radius:6px;padding:0 6px;font:12px/18px ui-monospace,Menlo,Consolas,monospace;color:var(--muted)}
    main{display:grid;grid-template-columns:2fr 1fr;gap:12px;padding:12px}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }
    .map-wrap{position:relative;min-height:60vh;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    #map{position:absolute;inset:0}
    .overlay{position:absolute;z-index:5}
    .top-center{top:10px;left:50%;transform:translateX(-50%)}
    .bottom-left{left:10px;bottom:10px}
    .bottom-center{left:50%;bottom:10px;transform:translateX(-50%)}
    .legend{background:var(--panel);border:1px solid var(--border);padding:10px;border-radius:10px}
    .sidebar{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:12px;min-height:60vh}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .card{border:1px solid var(--border);border-radius:10px;padding:10px}
    .title{font-weight:600;margin-bottom:6px}
    .big{font-size:28px;font-weight:700}
    .muted{color:var(--muted)}
    .bars{display:grid;gap:8px}
    .bar{display:grid;grid-template-columns:110px 1fr 48px;gap:8px;align-items:center}
    .bar .track{height:10px;border-radius:6px;background:#0b1a33;border:1px solid var(--border);overflow:hidden}
    .bar .fill{height:100%;background:linear-gradient(90deg,var(--good),var(--mid),var(--bad))}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    footer{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 14px;border-top:1px solid var(--border)}
    input[type="date"]{background:#fff;color:#000;border:1px solid #D0D7DE;padding:6px 8px;border-radius:8px}
    input[type="range"]{accent-color:#4ea1ff}
    .range-hint{font-size:11px;color:var(--muted);text-align:center;margin-top:4px}
    .cross{width:18px;height:18px;border:2px solid #fff;border-radius:50%;box-shadow:0 0 0 2px rgba(0,0,0,.3);position:relative;background:rgba(255,255,255,.1)}
    .cross:before,.cross:after{content:"";position:absolute;background:#fff}
    .cross:before{left:50%;top:2px;bottom:2px;width:2px;transform:translateX(-50%)}
    .cross:after{top:50%;left:2px;right:2px;height:2px;transform:translateY(-50%)}
    .fin{display:grid;place-items:center;width:28px;height:28px;border-radius:50%;background:rgba(155,108,255,.18);border:1px solid var(--violet);box-shadow:0 0 0 2px rgba(0,0,0,.25)}
    .fin span{font-size:16px}
    .fin-label{background:rgba(0,0,0,.45);color:#fff;padding:2px 6px;border-radius:6px;font-size:11px;margin-top:2px;white-space:nowrap}
    .backdrop{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:4000}
    .backdrop.open{display:flex}
    .modal{background:var(--panel); border:1px solid var(--border); border-radius:12px; max-width:1100px; width:min(96vw,1100px); max-height:90vh; display:flex; flex-direction:column; z-index:5000}
    .modal header,.modal footer{padding:10px 14px;border-bottom:1px solid var(--border)}
    .modal footer{border-top:1px solid var(--border);border-bottom:none;display:flex;gap:8px;justify-content:flex-end}
    .modal .body{padding:12px;display:grid;gap:12px}
    .compare{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .compare .panel{border:1px solid var(--border);border-radius:10px;overflow:hidden;position:relative;min-height:340px}
    .compare .label{position:absolute;top:8px;left:8px;background:rgba(0,0,0,.4);padding:4px 8px;border-radius:6px;font-size:12px}
    .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .kpis .kpi{border:1px solid var(--border);border-radius:10px;padding:10px}
    .pos{color:var(--good)} .neg{color:var(--bad)}
    .popover{position:fixed;right:12px;top:58px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;max-width:420px;z-index:15;display:none}
    .popover.open{display:block}
    .btn:focus, .seg button:focus, input:focus, a:focus {outline:2px solid var(--focus);outline-offset:2px}
    #map, .leaflet-container { z-index: 0 !important; }
    body.modal-open .leaflet-container,
    body.modal-open .leaflet-control-container { pointer-events:none !important; }
    body.modal-open .map-wrap { filter: saturate(80%) blur(1px); }
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  </style>
</head>
<body>
<div id="app" class="app">
  <header>
    <div class="brand">SharkScope <span class="pill">Demo</span></div>
    <div class="muted">Shark Habitat Support (Mock)</div>
    <div class="grow"></div>
    <div class="toolbar" role="group" aria-label="Top controls">
      <div class="seg" role="group" aria-label="View mode">
        <button id="modeRisk" class="btn-toggle" aria-pressed="false" title="Show risk (SHSR)">Risk</button>
        <button id="modeProb" class="btn-toggle" aria-pressed="true" title="Show shark probability (TCHI)">Probability</button>
      </div>
      <button id="restaurantsBtn" class="btn btn-toggle" aria-pressed="true" title="Toggle Shark Restaurants">Restaurants</button>
      <button id="infoBtn" class="btn" aria-haspopup="dialog" aria-controls="infoPop">Info</button>
      <button id="creditsBtn" class="btn" aria-haspopup="dialog" aria-controls="creditsPop">Credits</button>
      <button id="exportBtn" class="btn">Export PNG</button>
    </div>
  </header>

  <main>
    <section class="map-wrap" aria-label="Map">
      <div id="map" role="application" aria-label="Interactive map"></div>

      <div class="overlay top-center">
        <div class="row" style="justify-content:center">
          <button id="prevDay" class="btn" title="Previous day"><span class="kbd">Alt</span> ←</button>
          <label for="date" class="sr-only">Date</label>
          <input id="date" type="date" />
          <button id="nextDay" class="btn" title="Next day"><span class="kbd">Alt</span> →</button>
          <button id="play" class="btn">Play</button>
        </div>
      </div>

      <div class="overlay bottom-left">
        <div class="legend" aria-label="High-probability zones legend">
          <div id="legendTitle" style="font-size:12px;margin-bottom:4px">High‑probability zones</div>
          <div class="muted" style="font-size:12px">Translucent green circles = very high TCHI</div>
        </div>
      </div>

      <div class="overlay bottom-center">
        <div style="background:var(--panel);border:1px solid var(--border);padding:8px 10px;border-radius:10px;min-width:280px">
          <div style="font-size:12px;margin-bottom:6px" class="muted">Time Machine (−1 year … Today … +3 months)</div>
          <input id="timeSlider" type="range" min="-365" max="90" step="1" style="width:100%">
          <div class="range-hint"><span id="timeLabel">Today</span></div>
        </div>
      </div>
    </section>

    <aside class="sidebar" role="complementary" aria-labelledby="sideTitle">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div id="sideTitle" class="title">Analysis</div>
        <div id="locLabel" class="muted">Click the map</div>
      </div>

      <div class="cards">
        <div class="card">
          <div class="title">TCHI Support Score</div>
          <div class="big" id="tchiScore">–/100</div>
        </div>
        <div class="card">
          <div class="title">SHSR Risk</div>
          <div class="big" id="shsrScore">–%</div>
        </div>
      </div>

      <div class="card">
        <div class="title">Factor contributions</div>
        <div class="bars" id="factorBars"></div>
      </div>

      <div class="card">
        <div class="title">Time-series</div>
        <canvas id="spark" height="120"></canvas>
      </div>

      <div class="row" style="margin-top:auto;justify-content:space-between">
        <button id="simulateBtn" class="btn btn-primary" disabled>Run Mako‑Sense Simulation</button>
        <div id="restSummary" class="muted" style="font-size:12px"></div>
      </div>
    </aside>
  </main>

  <footer>
    <div class="muted">Click ocean to analyze. Zones show very high probability only. SHSR = (1 − TCHI) × 100</div>
    <div class="row"><span class="kbd">?</span> for help</div>
  </footer>
</div>

<!-- Info and Credits popovers -->
<div id="infoPop" class="popover" role="dialog" aria-modal="false" aria-labelledby="infoTitle">
  <div id="infoTitle" class="title">What am I seeing?</div>
  <p class="muted" style="margin:6px 0 8px">
    This mock demo removes the heatmap. Instead, it shows sparse, very low‑opacity green zones only where the probability (TCHI) is extremely high, and never on land. Factor panel now includes EKE and Bathymetry.
  </p>
</div>

<div id="creditsPop" class="popover" role="dialog" aria-modal="false" aria-labelledby="credTitle">
  <div id="credTitle" class="title">Credits & Data</div>
  <p class="muted" style="margin:6px 0 8px">
    Base map: NASA GIBS (MODIS Terra True Color) with graceful fallback to OSM. All fields are synthetic for demo realism; no network required.
  </p>
</div>

<!-- Simulation Modal -->
<div id="simBackdrop" class="backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="simTitle">
    <header><div id="simTitle" class="title">Mako‑Sense Simulation</div></header>
    <div class="body">
      <div class="kpis">
        <div class="kpi"><div class="muted">Previous TCHI</div><div class="big" id="prevTchi">–</div></div>
        <div class="kpi"><div class="muted">Refined TCHI</div><div class="big" id="refinedTchi">–</div></div>
        <div class="kpi"><div class="muted">Δ TCHI / Δ SHSR</div><div class="big" id="deltaTchi">–</div></div>
      </div>
      <div class="compare">
        <div class="panel"><div class="label">Before</div><div id="mapBefore" style="position:absolute;inset:0"></div></div>
        <div class="panel"><div class="label">After</div><div id="mapAfter" style="position:absolute;inset:0"></div></div>
      </div>
      <div class="muted">Visualization: Localized prey confirmation increases suitability within ~5 km (green circle).</div>
    </div>
    <footer>
      <button id="rerunSim" class="btn">Re‑run</button>
      <button id="closeSim" class="btn btn-primary">Close</button>
    </footer>
  </div>
</div>

<script>
// Quiet canvas warning; prefer willReadFrequently for 2D contexts
(function(){
  const orig = HTMLCanvasElement.prototype.getContext;
  HTMLCanvasElement.prototype.getContext = function(type, opts){
    if (type === '2d'){
      const o = Object.assign({ willReadFrequently: true }, opts || {});
      try { return orig.call(this, type, o); } catch(e){ return orig.call(this, type, opts); }
    }
    return orig.call(this, type, opts);
  };
})();

(function(){
  // ------------------ Utilities ------------------
  const $ = sel => document.querySelector(sel);
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const toFixed = (n, k=2) => Number.isFinite(n) ? n.toFixed(k) : "–";
  const fmtLatLon = (lat, lon) => `${Math.abs(lat).toFixed(2)}°${lat>=0?'N':'S'}, ${Math.abs(lon).toFixed(2)}°${lon>=0?'E':'W'}`;
  const todayISO = new Date().toISOString().slice(0,10);
  const parseISO = s => { const d = new Date(s); return isNaN(d) ? new Date() : d; };
  const addDays = (d, n) => { const x = new Date(d); x.setUTCDate(x.getUTCDate()+n); return x; };
  const iso = d => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().slice(0,10);
  const debounce = (fn, ms)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

  // ------------------ State (Mock only) ------------------
  const url = new URL(location.href);
  const minOffset = -365, maxOffset = 90;
  const initialDate = url.searchParams.get('date') || todayISO;
  const initialOffset = clamp(Math.round((parseISO(initialDate)-parseISO(todayISO))/86400000), minOffset, maxOffset);
  function dateFromOffset(off){ return iso(addDays(new Date(), off)); }
  function labelForOffset(off){ if (off===0) return "Today"; if (off<0) return `${Math.abs(off)} day${Math.abs(off)===1?'':'s'} ago`; return `In ${off} day${off===1?'':'s'}`; }

  const state = {
    date: dateFromOffset(initialOffset),
    offset: initialOffset,
    selected: url.searchParams.has('lat') && url.searchParams.has('lon') ? [parseFloat(url.searchParams.get('lat')), parseFloat(url.searchParams.get('lon'))] : null,
    heatMode: url.searchParams.get('mode') === 'risk' ? 'risk' : 'prob',
    restaurantsOn: url.searchParams.get('rest') !== 'off',
    playTimer: null
  };
  function updateURL(){
    const u = new URL(location.href);
    u.searchParams.set('date', state.date);
    u.searchParams.set('mode', state.heatMode);
    u.searchParams.set('rest', state.restaurantsOn ? 'on':'off');
    if (state.selected){ u.searchParams.set('lat', state.selected[0].toFixed(4)); u.searchParams.set('lon', state.selected[1].toFixed(4)); }
    history.replaceState(null, '', u.toString());
  }

  // ------------------ Map init and layers ------------------
  let map, baseLayer, markerDivIcon, restaurantsGroup, zonesLayer;
  let gibsFailed = false;

  function initMap(){
    map = L.map('map', {worldCopyJump:true, preferCanvas:true, minZoom:2}).setView([23.7,90.4], 3);

    const gibsUrl = 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/wmts.cgi';
    baseLayer = L.tileLayer.wms(gibsUrl, { layers: 'MODIS_Terra_CorrectedReflectance_TrueColor', tileSize: 512, format: 'image/png', transparent: false, attribution: 'NASA GIBS' });
    baseLayer.on('tileerror', ()=>{
      if (gibsFailed) return; gibsFailed = true;
      try{ if (map && baseLayer && map.hasLayer(baseLayer)) map.removeLayer(baseLayer); }catch(_){}
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'© OSM contributors'});
      if (map) { osm.addTo(map); baseLayer = osm; }
    });
    baseLayer.addTo(map);

    zonesLayer = L.layerGroup().addTo(map);
    markerDivIcon = L.divIcon({className:'', html:'<div class="cross" role="img" aria-label="Selected location"></div>', iconSize:[18,18], iconAnchor:[9,9]});
    restaurantsGroup = L.layerGroup().addTo(map);

    map.on('click', (e)=>{
      state.selected = [e.latlng.lat, e.latlng.lng];
      updateURL();
      setMarker();
      analyzePoint();
      $('#simulateBtn').disabled = false;
      $('#locLabel').textContent = fmtLatLon(...state.selected);
    });

    $('#date').value = state.date;
    $('#timeSlider').value = state.offset;
    $('#timeLabel').textContent = labelForOffset(state.offset);

    setMode(state.heatMode);
    setRestaurantsToggle(state.restaurantsOn);

    // Debounced updates
    map.on('moveend', debounce(refreshZones, 300));
    map.on('zoomend', debounce(refreshZones, 150));

    // Build land mask first
    buildLandMask().then(()=>{
      refreshZones();
      drawRestaurants();
      if (state.selected){ setMarker(); analyzePoint(); $('#simulateBtn').disabled = false; $('#locLabel').textContent = fmtLatLon(...state.selected); }
    });
  }

  let selMarker;
  function setMarker(){ if (selMarker) selMarker.remove(); selMarker = L.marker(state.selected, {icon: markerDivIcon, keyboard:false}).addTo(map); }

  function setMode(mode){
    state.heatMode = mode==='risk' ? 'risk' : 'prob';
    $('#modeRisk').setAttribute('aria-pressed', state.heatMode==='risk' ? 'true':'false');
    $('#modeProb').setAttribute('aria-pressed', state.heatMode==='prob' ? 'true':'false');
    $('#legendTitle').textContent = "High‑probability zones";
    updateURL();
    refreshZones();
  }
  $('#modeRisk').addEventListener('click', ()=> setMode('risk'));
  $('#modeProb').addEventListener('click', ()=> setMode('prob'));

  // ------------------ Ocean mask (offscreen canvas) ------------------
  const landMask = { data:null, w:2048, h:1024, ready:false };

  async function buildLandMask(){
    const topo = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json', {cache:'force-cache'}).then(r=>r.json());
    const land = topojson.feature(topo, topo.objects.land);
    const c = document.createElement('canvas'); c.width = landMask.w; c.height = landMask.h;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = '#ffffff';
    function proj(lat, lon){ const x=(lon+180)/360*landMask.w; const y=(90-lat)/180*landMask.h; return [x,y]; }
    ctx.beginPath();
    const drawPoly = coords => {
      coords.forEach(ring=>{
        for (let i=0;i<ring.length;i++){
          const [lon, lat] = ring[i];
          const [x,y] = proj(lat, lon);
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath();
      });
    };
    if (land.type === 'MultiPolygon'){ land.coordinates.forEach(drawPoly); }
    else if (land.type === 'Polygon'){ drawPoly(land.coordinates); }
    ctx.fill();
    landMask.data = ctx.getImageData(0,0,c.width,c.height).data;
    landMask.ready = true;
  }
  function isOcean(lat, lon){
    if (!landMask.ready) return true;
    lon = ((lon + 180) % 360 + 360) % 360 - 180;
    const x = Math.round((lon + 180) / 360 * (landMask.w-1));
    const y = Math.round((90 - lat) / 180 * (landMask.h-1));
    const idx = (y * landMask.w + x) * 4;
    return landMask.data[idx+3] === 0;
  }
  function coastDistancePx(lat, lon, maxR = 18){
    if (!landMask.ready) return maxR;
    lon = ((lon + 180) % 360 + 360) % 360 - 180;
    let x0 = (lon + 180) / 360 * (landMask.w-1);
    let y0 = (90 - lat) / 180 * (landMask.h-1);
    const dirs = [[1,0],[0,1],[-1,0],[0,-1],[0.707,0.707],[-0.707,0.707],[-0.707,-0.707],[0.707,-0.707]];
    const data = landMask.data, W = landMask.w, H = landMask.h;
    let best = maxR;
    for (const [dx,dy] of dirs){
      for (let r=1;r<=maxR;r++){
        const xi = Math.round(x0 + dx*r), yi = Math.round(y0 + dy*r);
        if (xi<0 || xi>=W || yi<0 || yi>=H) break;
        const a = data[(yi*W + xi)*4 + 3];
        if (a !== 0){ best = Math.min(best, r); break; }
      }
    }
    return best;
  }

  // ------------------ Mock physics (with EKE & Bathy) ------------------
  function seededRand(seed){ let x = Math.abs(Math.floor(seed)) % 2147483647; return () => (x = (x * 48271) % 2147483647) / 2147483647; }
  function hash2(i,j,seed){ const r = Math.sin(i*127.1 + j*311.7 + seed*0.12345)*43758.5453; return r - Math.floor(r); }
  function smoothstep(t){ return t*t*(3-2*t); }
  function valueNoise2D(x, y, seed){
    const i = Math.floor(x), j = Math.floor(y);
    const fx = x - i, fy = y - j;
    const a = hash2(i, j, seed), b = hash2(i+1, j, seed), c = hash2(i, j+1, seed), d = hash2(i+1, j+1, seed);
    const ux = smoothstep(fx), uy = smoothstep(fy);
    const ab = a*(1-ux) + b*ux, cd = c*(1-ux) + d*ux;
    return ab*(1-uy) + cd*uy;
  }
  function fbm2D(x, y, seed, oct=5, lac=2.06, gain=0.52){
    let amp=0.5, freq=1.0, sum=0.0, norm=0.0;
    for (let k=0;k<oct;k++){ sum += amp * valueNoise2D(x*freq, y*freq, seed + k*13.37); norm += amp; amp *= gain; freq *= lac; }
    return sum / norm;
  }
  const KNOWN_RESTS = [
    {lat:36.5, lon:-122.5, name:"Great White Bistro"},
    {lat:18.0, lon:  89.5, name:"Bengal Seal Buffet"},
    {lat:-34.0, lon: 18.5, name:"Cape Surf & Turf"},
    {lat:-31.0, lon:153.0, name:"Tasman Tuna Grill"}
  ];
  function hotspotBoost(lat,lon,dayPhase){
    let s=0;
    for(const h of KNOWN_RESTS){
      const d = Math.hypot((lat-h.lat)/4.5,(lon-h.lon)/4.5);
      const breathing = 0.85 + 0.15*Math.sin(dayPhase + (h.lat+h.lon)*0.03);
      s += Math.exp(-d*d*0.9)*0.9*breathing;
    }
    return clamp(s,0,1);
  }
  function dateIndexFromISO(s){ const epoch = new Date('2025-01-01T00:00:00Z'); return Math.round((parseISO(s)-epoch)/86400000); }

  function computeEKEandBathy(lat, lon, idx){
    // Normalize coords
    const x = (lon + 180) / 2.5;
    const y = (lat + 90) / 2.5;
    const seed = 1234;
    const t = idx*0.03;
    // Gradients for EKE proxy
    const dDeg = 0.06;
    const baseA = fbm2D(x + t*0.40, y - t*0.35, seed, 5, 2.05, 0.52);
    const baseP = fbm2D((x + dDeg) + t*0.40, y - t*0.35, seed, 5, 2.05, 0.52);
    const baseM = fbm2D((x - dDeg) + t*0.40, y - t*0.35, seed, 5, 2.05, 0.52);
    const fineP = fbm2D((x*2.7) - t*0.65, (y*2.7 + dDeg) + t*0.55, seed+77, 3, 2.3, 0.55);
    const fineM = fbm2D((x*2.7) - t*0.65, (y*2.7 - dDeg) + t*0.55, seed+77, 3, 2.3, 0.55);
    const gx = Math.abs(baseP-baseM) + 0.6*Math.abs(fineP-fineM);
    const gy = Math.abs(fineP-fineM) + 0.6*Math.abs(baseP-baseM);
    const eke = clamp(Math.sqrt(gx*gx + gy*gy) * 2.2, 0, 1); // 0..1
    const dpx = coastDistancePx(lat, lon, 18);
    const bathy = clamp(dpx / 18, 0, 1); // 0 shallow shelf, 1 deep ocean
    const shelfPref = Math.exp(-0.5*Math.pow((bathy-0.58)/0.18,2)); // preference (0..1)
    const ekePref = Math.exp(-0.5*Math.pow((eke-0.62)/0.22,2));     // preference (0..1)
    return { eke, bathy, ekePref, shelfPref };
  }

  function rawField(lat, lon, idx){
    if (!isOcean(lat, lon)) return 0;
    const x = (lon + 180) / 2.5;
    const y = (lat + 90) / 2.5;
    const seed = 1234;
    const t = idx*0.03;
    const base = fbm2D(x + t*0.40, y - t*0.35, seed, 5, 2.05, 0.52);
    const fine = fbm2D((x*2.7) - t*0.65, (y*2.7) + t*0.55, seed+77, 3, 2.3, 0.55);
    const { eke, bathy, ekePref, shelfPref } = computeEKEandBathy(lat, lon, idx);
    const latPref = Math.exp(-0.5*Math.pow((Math.abs(lat)-30)/18,2));
    const eddyPhase = 0.5 + 0.5*Math.sin((lat*lon)*Math.PI/180 * 0.08 + t*0.7);
    const hot = hotspotBoost(lat, lon, t);
    let v = 0.42*base + 0.22*fine + 0.14*latPref + 0.10*eddyPhase + 0.28*hot;
    v *= clamp(0.70 + 0.45*shelfPref, 0, 1.25);
    v *= clamp(0.75 + 0.35*ekePref,   0, 1.20);
    return clamp(v, 0, 1);
  }

  // Factor triplet (keep for continuity) + show EKE/Bathy in panel
  const W = { sst:0.45, chla:0.35, tfg:0.20 };
  function factorsFromField(lat, lon, idx){
    const v = rawField(lat, lon, idx);
    const r1 = Math.sin((lat+lon+idx)*0.1)*0.5+0.5;
    const r2 = Math.cos((lat*0.5-idx)*0.08)*0.5+0.5;
    const sst  = clamp(0.35 + 0.55*v + 0.10*r1, 0, 1);
    const chla = clamp(0.30 + 0.60*v + 0.10*r2, 0, 1);
    const tfg  = clamp(0.25 + 0.75*v + 0.20*(1-Math.abs(r1-r2)), 0, 1);
    const { eke, bathy, ekePref, shelfPref } = computeEKEandBathy(lat, lon, idx);
    return { sst, chla, tfg, eke, bathy, ekePref, shelfPref };
  }
  function tchiFromFactors(F){
    const eps=1e-6, logSum = (W.sst*Math.log(F.sst+eps)) + (W.chla*Math.log(F.chla+eps)) + (W.tfg*Math.log(F.tfg+eps));
    const wsum = W.sst + W.chla + W.tfg;
    return clamp(Math.exp(logSum/wsum),0,1);
  }

  // ------------------ Zones (no heatmap) ------------------
  function refreshZones(){
    if (!landMask.ready) return;
    zonesLayer.clearLayers();

    const idx = dateIndexFromISO(state.date);
    const b = map.getBounds();
    const latS = b.getSouth(), latN = b.getNorth(), lonW = b.getWest(), lonE = b.getEast();
    const latSpan = Math.max(3.0, latN - latS);
    const lonSpan = Math.max(3.0, lonE - lonW);

    // Sample modest grid with jitter
    const target = 1600;
    const rows = Math.max(12, Math.round(Math.sqrt(target * (latSpan/lonSpan))));
    const cols = Math.max(12, Math.round(Math.sqrt(target * (lonSpan/latSpan))));
    const dLat = (latN - latS) / rows;
    const dLon = (lonE - lonW) / cols;
    const rand = seededRand(idx*1337 + Math.floor(latS*10) + Math.floor(lonW*10));
    const candidates = [];

    for (let i=0;i<rows;i++){
      for (let j=0;j<cols;j++){
        const lat = latS + (i + 0.25 + 0.5*rand())*dLat;
        const lon = lonW + (j + 0.25 + 0.5*rand())*dLon;
        if (!isOcean(lat, lon)) continue;
        const F = factorsFromField(lat, lon, idx);
        const tchi = tchiFromFactors(F);
        candidates.push({ lat, lon, tchi });
      }
    }

    // Keep only very high probability and pick top K (avoid carpet)
    const threshold = 0.85;
    const highs = candidates.filter(c=>c.tchi >= threshold).sort((a,b)=>b.tchi - a.tchi);
    const zoom = map.getZoom();
    const maxZones = clamp(Math.round(30 + (zoom-3)*6), 12, 64);
    const picked = highs.slice(0, maxZones);

    // Render translucent green circles (meters)
    picked.forEach((p, k)=>{
      const rKm = 5000 + (rand()*7000); // 5–12 km
      L.circle([p.lat, p.lon], {
        radius: rKm,
        color: '#2ECC71',
        weight: 1,
        opacity: 0.15,
        fillColor: '#2ECC71',
        fillOpacity: 0.12
      }).addTo(zonesLayer);
    });
  }

  // ------------------ Restaurants ------------------
  let restaurantMarkers = [];
  function fancyName(lat, lon, idx){
    const adj = ["Savage","Silent","Rogue","Apex","Midnight","Electric","Emerald","Silver","Turbo","Crimson"];
    const noun = ["Fin","Reef","Dorsal","Bite","Chomp","Current","Tide","Surge","Strike","Hunt"];
    const r = seededRand((lat*1000+lon*1000+idx*13));
    return `${adj[Math.floor(r()*adj.length)]} ${noun[Math.floor(r()*noun.length)]} Grill`;
  }
  function drawRestaurants(){
    restaurantsGroup.clearLayers(); restaurantMarkers = [];
    // Fixed known
    KNOWN_RESTS.forEach(k=>{
      if (!isOcean(k.lat, k.lon)) return;
      const icon = L.divIcon({className:'', iconSize:[28,32], iconAnchor:[14,14], html:`<div class="fin"><span>🦈</span></div><div class="fin-label">${k.name}</div>`});
      const m = L.marker([k.lat, k.lon], {icon, keyboard:false}).addTo(restaurantsGroup);
      restaurantMarkers.push(m);
    });
    // Top predicted in view
    const idx = dateIndexFromISO(state.date);
    const b = map.getBounds();
    const latS=b.getSouth(), latN=b.getNorth(), lonW=b.getWest(), lonE=b.getEast();
    const step = Math.max(1.5, Math.min(3.0, (latN-latS)/6));
    const cands = [];
    for(let lat=Math.floor(latS); lat<=Math.ceil(latN); lat+=step){
      for(let lon=Math.floor(lonW); lon<=Math.ceil(lonE); lon+=step){
        if (!isOcean(lat, lon)) continue;
        const F = factorsFromField(lat+0.3, lon+0.3, idx);
        cands.push({ lat, lon, p: tchiFromFactors(F) });
      }
    }
    cands.sort((a,b)=>b.p-a.p);
    cands.slice(0,3).forEach(c=>{
      const name = fancyName(c.lat, c.lon, idx);
      const icon = L.divIcon({className:'', iconSize:[28,32], iconAnchor:[14,14], html:`<div class="fin" style="background:rgba(46,204,113,.18);border-color:var(--good)"><span>⭐</span></div><div class="fin-label">${name}</div>`});
      const m = L.marker([c.lat, c.lon], {icon, keyboard:false}).addTo(restaurantsGroup);
      restaurantMarkers.push(m);
    });
    $('#restSummary').textContent = state.restaurantsOn ? `Restaurants: ${restaurantMarkers.length}` : '';
    if (!state.restaurantsOn) restaurantsGroup.remove(); else if (!map.hasLayer(restaurantsGroup)) restaurantsGroup.addTo(map);
  }
  function setRestaurantsToggle(on){
    state.restaurantsOn = !!on;
    $('#restaurantsBtn').setAttribute('aria-pressed', on ? 'true' : 'false');
    if (on) { if (!map.hasLayer(restaurantsGroup)) restaurantsGroup.addTo(map); drawRestaurants(); }
    else { restaurantsGroup.remove(); }
    updateURL();
  }
  $('#restaurantsBtn').addEventListener('click', ()=> setRestaurantsToggle(!state.restaurantsOn));

  // ------------------ Sidebar analysis (with EKE & Bathy) ------------------
  let sparkChart;
  function renderFactors(F){
    // Show classic three plus EKE pref and Bathymetry pref; also show raw EKE and depth hint
    const rows = [
      ["SST", clamp(F.sst,0,1)],
      ["Chl‑a", clamp(F.chla,0,1)],
      ["TFG", clamp(F.tfg,0,1)],
      ["EKE (pref)", clamp(F.ekePref,0,1)],
      ["Bathymetry (shelf)", clamp(F.shelfPref,0,1)]
    ];
    const wrap = $('#factorBars'); wrap.innerHTML = "";
    rows.forEach(([label,val])=>{
      const pct = Math.round(val*100);
      const row = document.createElement('div'); row.className='bar';
      row.innerHTML = `<div class="muted">${label}</div><div class="track"><div class="fill" style="width:${pct}%"></div></div><div>${pct}%</div>`;
      wrap.appendChild(row);
    });
  }
  function renderSpark(series){
    const ctx = $('#spark').getContext('2d');
    const labels = series.map(s=>s.date.slice(5));
    const vals = series.map(s=>+(s.tchi*100).toFixed(2));
    if (sparkChart){ sparkChart.destroy(); }
    sparkChart = new Chart(ctx, {
      type:'line',
      data:{ labels, datasets:[{ label:'TCHI (/100)', data:vals, borderColor:'#3BA3FF', backgroundColor:'rgba(59,163,255,.15)', tension:.25, fill:true, pointRadius:3 }]},
      options:{ responsive:true, plugins:{legend:{display:false}}, scales:{ y:{min:0,max:100,grid:{color:'rgba(255,255,255,.06)'}}, x:{grid:{display:false}} } }
    });
  }
  async function analyzePoint(){
    if (!state.selected) return;
    const [lat, lon] = state.selected;
    $('#locLabel').textContent = fmtLatLon(lat, lon);
    const idx = dateIndexFromISO(state.date);
    const series = [];
    for (let d=-4; d<=2; d++){
      const di = idx + d;
      const isoDay = iso(addDays(parseISO(state.date), d));
      const f = factorsFromField(lat, lon, di);
      series.push({date: isoDay, tchi: tchiFromFactors(f), factors: f});
    }
    const latest = series[4];
    const shsr = (1 - latest.tchi) * 100;
    $('#tchiScore').textContent = `${Math.round(latest.tchi*100)}/100`;
    $('#shsrScore').textContent = `${Math.round(shsr)}%`;
    renderFactors(latest.factors);
    renderSpark(series);
  }

  // ------------------ Date & controls ------------------
  function setDateFromOffset(off){
    state.offset = clamp(off, minOffset, maxOffset);
    state.date = dateFromOffset(state.offset);
    $('#date').value = state.date; $('#timeSlider').value = state.offset; $('#timeLabel').textContent = labelForOffset(state.offset);
    updateURL(); refreshZones(); drawRestaurants(); analyzePoint();
  }
  $('#date').addEventListener('change', (e)=>{
    const picked = e.target.value || todayISO;
    const offset = Math.round((parseISO(picked) - parseISO(todayISO))/86400000);
    setDateFromOffset(offset);
  });
  $('#timeSlider').addEventListener('input', (e)=> $('#timeLabel').textContent = labelForOffset(parseInt(e.target.value||'0',10)));
  $('#timeSlider').addEventListener('change', (e)=> setDateFromOffset(parseInt(e.target.value||'0',10)));
  $('#prevDay').addEventListener('click', ()=> setDateFromOffset(state.offset - 1));
  $('#nextDay').addEventListener('click', ()=> setDateFromOffset(state.offset + 1));
  document.addEventListener('keydown', (e)=>{ if (e.altKey && e.key==='ArrowLeft') $('#prevDay').click(); if (e.altKey && e.key==='ArrowRight') $('#nextDay').click(); if (e.key==='?') togglePop($('#infoPop')); });

  // ------------------ Info & Credits ------------------
  function togglePop(pop){ const open = pop.classList.toggle('open'); pop.setAttribute('aria-modal', open ? 'true' : 'false'); }
  $('#infoBtn').addEventListener('click', ()=>togglePop($('#infoPop')));
  $('#creditsBtn').addEventListener('click', ()=>togglePop($('#creditsPop')));
  document.addEventListener('click', (e)=>{ if (!$('#infoPop').contains(e.target) && e.target !== $('#infoBtn')) $('#infoPop').classList.remove('open');
                                            if (!$('#creditsPop').contains(e.target) && e.target !== $('#creditsBtn')) $('#creditsPop').classList.remove('open'); });

  // ------------------ Export PNG ------------------
  $('#exportBtn').addEventListener('click', async ()=>{
    const node = document.getElementById('app');
    const canvas = await html2canvas(node, {backgroundColor: null, scale: 2, useCORS: true});
    const link = document.createElement('a'); link.download = `sharkscope_${state.date}_${state.heatMode}_zones_mock.png`;
    link.href = canvas.toDataURL('image/png'); link.click();
  });

  // ------------------ Simulation Modal (unchanged mock) ------------------
  const sim = { open:false, maps:{before:null, after:null}, circle:null };
  function openSim(){
    if (!state.selected) return;
    const [lat, lon] = state.selected;
    const idx = dateIndexFromISO(state.date);
    const F = factorsFromField(lat, lon, idx);
    const prev = tchiFromFactors(F);
    const refined = clamp(prev + 0.14, 0, 1);
    $('#prevTchi').textContent = toFixed(prev,2);
    $('#refinedTchi').textContent = toFixed(refined,2);
    const dT = refined - prev, dS = -((1-refined) - (1-prev)) * 100;
    $('#deltaTchi').innerHTML = `<span class="${dT>=0?'pos':'neg'}">${dT>=0?'+':''}${toFixed(dT,2)}  /  ${dS>=0?'-':''}${Math.abs(dS).toFixed(0)}%</span>`;

    $('#simBackdrop').classList.add('open');
    document.body.style.overflow='hidden';
    document.body.classList.add('modal-open');
    initSimMaps(lat, lon);
    sim.open = true;
  }
  function initSimMaps(lat, lon){
    if (sim.maps.before){ sim.maps.before.remove(); sim.maps.after.remove(); sim.circle=null; }
    const opts = {worldCopyJump:true, preferCanvas:true, zoom:8, center:[lat,lon], attributionControl:false};
    const gibsUrl = 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/wmts.cgi';
    const makeBase = () => L.tileLayer.wms(gibsUrl, {layers:'MODIS_Terra_CorrectedReflectance_TrueColor', tileSize:512, format:'image/png'});

    sim.maps.before = L.map('mapBefore', opts);
    const bL = makeBase().addTo(sim.maps.before);

    sim.maps.after = L.map('mapAfter', opts);
    const aL = makeBase().addTo(sim.maps.after);

    sim.circle = L.circle([lat,lon], {radius:5000, color:'#2ECC71', weight:2, fillColor:'#2ECC71', fillOpacity:.25}).addTo(sim.maps.after);

    setTimeout(()=>{ sim.maps.before.invalidateSize(); sim.maps.after.invalidateSize(); }, 60);
    [bL, aL].forEach(layer=> layer.on('tileerror', ()=>{ const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'); try{ layer.remove(); }catch(_){} osm.addTo(layer._map); }));
  }
  $('#simulateBtn').addEventListener('click', openSim);
  $('#closeSim').addEventListener('click', ()=>{ $('#simBackdrop').classList.remove('open'); document.body.style.overflow=''; document.body.classList.remove('modal-open'); sim.open=false; });
  $('#rerunSim').addEventListener('click', openSim);
  $('#simBackdrop').addEventListener('click', (e)=>{ if (e.target.id==='simBackdrop') $('#closeSim').click(); });

  // ------------------ Boot ------------------
  window.addEventListener('load', ()=>{ 
    initMap(); 
    updateURL();
    // Wire play control
    $('#play').addEventListener('click', ()=>{
      if (state.playTimer){ clearInterval(state.playTimer); state.playTimer=null; $('#play').textContent='Play'; return; }
      $('#play').textContent='Pause';
      state.playTimer = setInterval(()=>{
        let next = state.offset + 1;
        if (next > maxOffset) next = minOffset;
        setDateFromOffset(next);
      }, 900);
    });
  });
})();
</script>
</body>
</html>