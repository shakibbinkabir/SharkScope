<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SharkScope — Shark Habitat Support Risk (Demo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet Heat -->
  <script defer src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <!-- Chart.js -->
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <!-- html2canvas for export -->
  <script defer src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <style>
    :root{
      --bg:#0A192F; --panel:#0F2547; --fg:#E6EDF3; --muted:#9AA4AE; --border:#1C325A;
      --accent:#3BA3FF; --good:#2ECC71; --mid:#F1C40F; --bad:#E74C3C; --focus:#86B7FE;
      --violet:#9b6cff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}
    a{color:#8bc1ff}
    .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header{display:flex;align-items:center;gap:12px;padding:10px 14px;border-bottom:1px solid var(--border);position:sticky;top:0;background:rgba(10,25,47,.9);backdrop-filter:saturate(120%) blur(4px);z-index:10}
    .brand{font-weight:700;letter-spacing:.3px}
    .pill{border:1px solid var(--border);padding:2px 8px;border-radius:999px;font-size:12px;color:var(--muted)}
    .grow{flex:1}
    .toolbar{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid var(--border);color:var(--fg);padding:6px 10px;border-radius:8px;cursor:pointer}
    .btn:hover{border-color:#2b4b86}
    .btn-primary{background:#1b3a6a;border-color:#1b3a6a}
    .btn-primary:hover{background:#234a86}
    .btn-toggle[aria-pressed="true"]{background:#18335f;border-color:#2b4b86}
    .seg{display:inline-flex;border:1px solid var(--border);border-radius:10px;overflow:hidden}
    .seg button{border:0;padding:6px 10px;background:transparent;color:var(--fg);cursor:pointer}
    .seg button[aria-pressed="true"]{background:#16315a}
    .kbd{border:1px solid var(--border);border-bottom-width:2px;border-radius:6px;padding:0 6px;font:12px/18px ui-monospace,Menlo,Consolas,monospace;color:var(--muted)}
    main{display:grid;grid-template-columns:2fr 1fr;gap:12px;padding:12px}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }
    .map-wrap{position:relative;min-height:60vh;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    #map{position:absolute;inset:0}
    .overlay{position:absolute;z-index:5}
    .top-center{top:10px;left:50%;transform:translateX(-50%)}
    .bottom-left{left:10px;bottom:10px}
    .bottom-center{left:50%;bottom:10px;transform:translateX(-50%)}
    .legend{background:var(--panel);border:1px solid var(--border);padding:10px;border-radius:10px}
    .grad{height:12px;border-radius:6px;background:linear-gradient(90deg,var(--good),var(--mid),var(--bad))}
    .legend .ticks{display:flex;justify-content:space-between;font-size:12px;color:var(--muted);margin-top:6px}
    .legend .labels{display:flex;justify-content:space-between;font-size:11px;margin-top:2px}
    .sidebar{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:12px;min-height:60vh}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .card{border:1px solid var(--border);border-radius:10px;padding:10px}
    .title{font-weight:600;margin-bottom:6px}
    .big{font-size:28px;font-weight:700}
    .muted{color:var(--muted)}
    .bars{display:grid;gap:8px}
    .bar{display:grid;grid-template-columns:80px 1fr 48px;gap:8px;align-items:center}
    .bar .track{height:10px;border-radius:6px;background:#0b1a33;border:1px solid var(--border);overflow:hidden}
    .bar .fill{height:100%;background:linear-gradient(90deg,var(--good),var(--mid),var(--bad))}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    footer{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 14px;border-top:1px solid var(--border)}

    /* Date input: black on white */
    input[type="date"]{background:#fff;color:#000;border:1px solid #D0D7DE;padding:6px 8px;border-radius:8px}
    input[type="date"]::placeholder{color:#555}

    input[type="range"]{accent-color:#4ea1ff}
    .range-hint{font-size:11px;color:var(--muted);text-align:center;margin-top:4px}

    /* Crosshair marker */
    .cross{width:18px;height:18px;border:2px solid #fff;border-radius:50%;box-shadow:0 0 0 2px rgba(0,0,0,.3);position:relative;background:rgba(255,255,255,.1)}
    .cross:before,.cross:after{content:"";position:absolute;background:#fff}
    .cross:before{left:50%;top:2px;bottom:2px;width:2px;transform:translateX(-50%)}
    .cross:after{top:50%;left:2px;right:2px;height:2px;transform:translateY(-50%)}

    /* Restaurant marker */
    .fin{display:grid;place-items:center;width:28px;height:28px;border-radius:50%;background:rgba(155,108,255,.18);border:1px solid var(--violet);box-shadow:0 0 0 2px rgba(0,0,0,.25)}
    .fin span{font-size:16px}
    .fin-label{background:rgba(0,0,0,.45);color:#fff;padding:2px 6px;border-radius:6px;font-size:11px;margin-top:2px;white-space:nowrap}

    /* Modal (z-index above Leaflet) */
    .backdrop{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:4000}
    .backdrop.open{display:flex}
    .modal{background:var(--panel); border:1px solid var(--border); border-radius:12px; max-width:1100px; width:min(96vw,1100px); max-height:90vh; display:flex; flex-direction:column; z-index:5000}
    .modal header,.modal footer{padding:10px 14px;border-bottom:1px solid var(--border)}
    .modal footer{border-top:1px solid var(--border);border-bottom:none;display:flex;gap:8px;justify-content:flex-end}
    .modal .body{padding:12px;display:grid;gap:12px}
    .compare{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .compare .panel{border:1px solid var(--border);border-radius:10px;overflow:hidden;position:relative;min-height:340px}
    .compare .label{position:absolute;top:8px;left:8px;background:rgba(0,0,0,.4);padding:4px 8px;border-radius:6px;font-size:12px}
    .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .kpis .kpi{border:1px solid var(--border);border-radius:10px;padding:10px}
    .pos{color:var(--good)} .neg{color:var(--bad)}

    /* Popovers */
    .popover{position:fixed;right:12px;top:58px;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;max-width:420px;z-index:15;display:none}
    .popover.open{display:block}

    /* Focus */
    .btn:focus, .seg button:focus, input:focus, a:focus {outline:2px solid var(--focus);outline-offset:2px}

    /* Keep map below overlays */
    #map, .leaflet-container { z-index: 0 !important; }

    /* When modal is open, block map interactions and dim slightly */
    body.modal-open .leaflet-container,
    body.modal-open .leaflet-control-container { pointer-events:none !important; }
    body.modal-open .map-wrap { filter: saturate(80%) blur(1px); }
  </style>
</head>
<body>
<div id="app" class="app">
  <header>
    <div class="brand">SharkScope <span class="pill">Demo</span></div>
    <div class="muted">Shark Habitat Support Risk</div>
    <div class="grow"></div>
    <div class="toolbar" role="group" aria-label="Top controls">
      <div class="seg" role="group" aria-label="Heat layer mode">
        <button id="modeRisk" class="btn-toggle" aria-pressed="true" title="Show risk (SHSR)">Risk</button>
        <button id="modeProb" class="btn-toggle" aria-pressed="false" title="Show shark probability (TCHI)">Probability</button>
      </div>
      <button id="restaurantsBtn" class="btn btn-toggle" aria-pressed="true" title="Toggle Shark Restaurants">Restaurants</button>
      <button id="dataModeBtn" class="btn btn-toggle" aria-pressed="false" title="Toggle Real Data mode">Data: Mock</button>
      <button id="infoBtn" class="btn" aria-haspopup="dialog" aria-controls="infoPop">Info</button>
      <button id="creditsBtn" class="btn" aria-haspopup="dialog" aria-controls="creditsPop">Credits</button>
      <button id="exportBtn" class="btn">Export PNG</button>
    </div>
  </header>

  <main>
    <section class="map-wrap" aria-label="Map">
      <div id="map" role="application" aria-label="Interactive map"></div>

      <div class="overlay top-center">
        <div class="row" style="justify-content:center">
          <button id="prevDay" class="btn" title="Previous day"><span class="kbd">Alt</span> ←</button>
          <label for="date" class="sr-only">Date</label>
          <input id="date" type="date" />
          <button id="nextDay" class="btn" title="Next day"><span class="kbd">Alt</span> →</button>
          <button id="play" class="btn">Play</button>
        </div>
      </div>

      <div class="overlay bottom-center">
        <div style="background:var(--panel);border:1px solid var(--border);padding:8px 10px;border-radius:10px;min-width:280px">
          <div style="font-size:12px;margin-bottom:6px" class="muted">Time Machine (−1 year … Today … +3 months)</div>
          <input id="timeSlider" type="range" min="-365" max="90" step="1" style="width:100%">
          <div class="range-hint"><span id="timeLabel">Today</span></div>
        </div>
      </div>

      <div class="overlay bottom-left">
        <div class="legend" aria-label="SHSR/Probability color legend">
          <div id="legendTitle" style="font-size:12px;margin-bottom:4px">SHSR (%) — lower is better</div>
          <div id="legendGrad" class="grad"></div>
          <div class="ticks"><span>0</span><span>25</span><span>50</span><span>75</span><span>100</span></div>
          <div class="labels"><span id="legendLeft">Low risk</span><span id="legendRight">High risk</span></div>
        </div>
      </div>
    </section>

    <aside class="sidebar" role="complementary" aria-labelledby="sideTitle">
      <div class="row" style="justify-content:space-between;align-items:center">
        <div id="sideTitle" class="title">Analysis</div>
        <div id="locLabel" class="muted">Click the map</div>
      </div>

      <div class="cards">
        <div class="card">
          <div class="title">TCHI Support Score</div>
          <div class="big" id="tchiScore">–/100</div>
        </div>
        <div class="card">
          <div class="title">SHSR Risk</div>
          <div class="big" id="shsrScore">–%</div>
        </div>
      </div>

      <div class="card">
        <div class="title">Factor contributions</div>
        <div class="bars" id="factorBars"></div>
      </div>

      <div class="card">
        <div class="title">Time-series</div>
        <canvas id="spark" height="120"></canvas>
      </div>

      <div class="row" style="margin-top:auto;justify-content:space-between">
        <button id="simulateBtn" class="btn btn-primary" disabled>Run Mako‑Sense Simulation</button>
        <div id="restSummary" class="muted" style="font-size:12px"></div>
      </div>
    </aside>
  </main>

  <footer>
    <div class="muted">Tip: Click the ocean. TCHI shows habitat support (0–1 ➝ /100). SHSR = (1 − TCHI) × 100</div>
    <div class="row"><span class="kbd">?</span> for help</div>
  </footer>
</div>

<!-- Info and Credits popovers -->
<div id="infoPop" class="popover" role="dialog" aria-modal="false" aria-labelledby="infoTitle">
  <div id="infoTitle" class="title">What am I seeing?</div>
  <p class="muted" style="margin:6px 0 8px">
    TCHI is a weighted geometric mean of suitability scores from satellite data:
    SST, Chlorophyll‑a, Thermal Front Gradient; EKE and Bathymetry are coming in Real‑Data mode once sources are confirmed.
  </p>
  <ul style="margin:0 0 8px 18px;color:#c9d6ea">
    <li>Support Score (TCHI): 0–1 shown as /100 (higher = better habitat).</li>
    <li>SHSR (%): (1 − TCHI) × 100 (higher = higher risk, lower support).</li>
    <li>Probability heatmap shows TCHI; Risk heatmap shows SHSR.</li>
    <li>“Shark Restaurants” are historically active and predicted hotspots from the current TCHI grid.</li>
    <li>Real Data mode uses JPL MUR SST and VIIRS Chl‑a via ERDDAP; gradients computed on‑the‑fly.</li>
  </ul>
</div>

<div id="creditsPop" class="popover" role="dialog" aria-modal="false" aria-labelledby="credTitle">
  <div id="credTitle" class="title">Credits & Data</div>
  <p class="muted" style="margin:6px 0 8px">
    Base map: NASA GIBS (MODIS Terra True Color). Real Data mode: JPL MUR SST v4.1 and VIIRS Chl‑a (8‑day) via NOAA ERDDAP (NASA/JPL provenance). Heatmap computed client‑side.
  </p>
  <p class="muted" style="margin:0">
    Planned additions: DUACS EKE (Copernicus Marine/PO.DAAC) and GEBCO/ETOPO bathymetry.
  </p>
</div>

<!-- Simulation Modal -->
<div id="simBackdrop" class="backdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="simTitle">
    <header><div id="simTitle" class="title">Mako‑Sense Simulation</div></header>
    <div class="body">
      <div class="kpis">
        <div class="kpi"><div class="muted">Previous TCHI</div><div class="big" id="prevTchi">–</div></div>
        <div class="kpi"><div class="muted">Refined TCHI</div><div class="big" id="refinedTchi">–</div></div>
        <div class="kpi"><div class="muted">Δ TCHI / Δ SHSR</div><div class="big" id="deltaTchi">–</div></div>
      </div>
      <div class="compare">
        <div class="panel"><div class="label">Before</div><div id="mapBefore" style="position:absolute;inset:0"></div></div>
        <div class="panel"><div class="label">After</div><div id="mapAfter" style="position:absolute;inset:0"></div></div>
      </div>
      <div class="muted">Visualization: Localized prey confirmation increases suitability within ~5 km (green circle).</div>
    </div>
    <footer>
      <button id="rerunSim" class="btn">Re‑run</button>
      <button id="closeSim" class="btn btn-primary">Close</button>
    </footer>
  </div>
</div>

<script>
(function(){
  // ------------------ Utilities ------------------
  const $ = sel => document.querySelector(sel);
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const toFixed = (n, k=2) => Number.isFinite(n) ? n.toFixed(k) : "–";
  const fmtLatLon = (lat, lon) => `${Math.abs(lat).toFixed(2)}°${lat>=0?'N':'S'}, ${Math.abs(lon).toFixed(2)}°${lon>=0?'E':'W'}`;
  const todayISO = new Date().toISOString().slice(0,10);
  const parseISO = s => { const d = new Date(s); return isNaN(d) ? new Date() : d; };
  const addDays = (d, n) => { const x = new Date(d); x.setUTCDate(x.getUTCDate()+n); return x; };
  const iso = d => new Date(d.getTime() - d.getTimezoneOffset()*60000).toISOString().slice(0,10);
  const diffDays = (a,b) => Math.round((parseISO(a)-parseISO(b))/86400000);

  // Weights (renormalized in code based on available parts)
  const W = {bathy:0.32, sst:0.28, tfg:0.20, eke:0.10, chla:0.10};

  // ------------------ State ------------------
  const url = new URL(location.href);
  const minOffset = -365, maxOffset = 90;
  const initialDate = url.searchParams.get('date') || todayISO;
  let initialOffset = clamp(Math.round((parseISO(initialDate)-parseISO(todayISO))/86400000), minOffset, maxOffset);
  function dateFromOffset(off){ return iso(addDays(new Date(), off)); }
  function labelForOffset(off){ if (off===0) return "Today"; if (off<0) return `${Math.abs(off)} day${Math.abs(off)===1?"":"s"} ago`; return `In ${off} day${off===1?"":"s"}`; }
  const state = {
    date: dateFromOffset(initialOffset),
    offset: initialOffset,
    selected: url.searchParams.has('lat') && url.searchParams.has('lon') ? [parseFloat(url.searchParams.get('lat')), parseFloat(url.searchParams.get('lon'))] : null,
    playTimer: null,
    heatMode: url.searchParams.get('mode') === 'prob' ? 'prob' : 'risk',
    restaurantsOn: url.searchParams.get('rest') !== 'off',
    realData: url.searchParams.get('data') === 'real'
  };

  // ------------------ Real-data ERDDAP via local CORS proxy ------------------
  const USE_PROXY = true;
  const ERDDAP_DIRECT = "https://coastwatch.pfeg.noaa.gov/erddap/griddap";
  const ERDDAP_PROXY = "http://127.0.0.1:8765/proxy?url=";

  // Build full direct ERDDAP URL, then wrap with proxy (percent-encode the WHOLE thing)
  function erddapUrl(ds, varName, dateISO, bbox, stepDeg=1, useLast=false) {
    const t = useLast ? "(last)" : `(${dateISO}T00:00:00Z)`;
    const lat0 = Math.max(-89.5, Math.floor(bbox.s));
    const lat1 = Math.min( 89.5, Math.ceil(bbox.n));
    const lon0 = Math.floor(bbox.w);
    const lon1 = Math.ceil(bbox.e);
    const step = stepDeg.toFixed(2);
    const direct = `${ERDDAP_DIRECT}/${ds}.json?${varName}[${t}][(${lat0}):${step}:(${lat1})][(${lon0}):${step}:(${lon1})]`;
    return USE_PROXY ? `${ERDDAP_PROXY}${encodeURIComponent(direct)}` : direct;
  }

  // Fetch grid: try exact date, then fallback to latest "(last)"
  async function fetchGrid(ds, varName, dateISO, bbox, stepDeg=1){
    const urls = [
      erddapUrl(ds, varName, dateISO, bbox, stepDeg, false),
      erddapUrl(ds, varName, dateISO, bbox, stepDeg, true)
    ];
    for (const u of urls){
      try{
        const r = await fetch(u, { mode: "cors" });
        if (!r.ok) { console.warn("ERDDAP HTTP", r.status, u); continue; }
        const js = await r.json();
        const cols = js?.table?.columnNames, rows = js?.table?.rows || [];
        if (!cols || !rows.length) { console.warn("ERDDAP empty table", u); continue; }
        const latI = cols.indexOf("lat"), lonI = cols.indexOf("lon"), valI = cols.indexOf(varName);
        if (latI<0 || lonI<0 || valI<0) { console.warn("Columns missing", cols); continue; }
        const lats = [...new Set(rows.map(r=>r[latI]))].sort((a,b)=>a-b);
        const lons = [...new Set(rows.map(r=>r[lonI]))].sort((a,b)=>a-b);
        const vals = Array(lats.length).fill(0).map(()=>Array(lons.length).fill(null));
        rows.forEach(row => {
          const ii = lats.indexOf(row[latI]), jj = lons.indexOf(row[lonI]);
          vals[ii][jj] = (row[valI]==null || Number.isNaN(row[valI])) ? null : row[valI];
        });
        return { lats, lons, vals, var: varName };
      }catch(e){ console.warn("ERDDAP fetch failed", u, e); continue; }
    }
    return null;
  }

  // -------------- Suitability curves and helpers (unchanged) --------------
  function kelvinToC(k){ return k - 273.15; }
  function gradientMag(gridC){
    const {lats,lons,vals} = gridC;
    const n = lats.length, m=lons.length;
    const g = Array(n).fill(0).map(()=>Array(m).fill(null));
    for(let i=1;i<n-1;i++){
      for(let j=1;j<m-1;j++){
        const v = vals[i][j]; if (v==null){ g[i][j]=null; continue; }
        const dvdy = (vals[i+1][j] - vals[i-1][j]) / (lats[i+1]-lats[i-1]);
        const dvdx = (vals[i][j+1] - vals[i][j-1]) / (lons[j+1]-lons[j-1]);
        g[i][j] = Math.sqrt(dvdy*dvdy + dvdx*dvdx) * (100/111);
      }
    }
    return {lats,lons,vals:g};
  }
  const params = { T_opt: 15.5, sigma_T: 6.0, mu_c: 0, sigma_c: 1.0, alpha_f: 0.5 };
  function S_sst(T){ return Math.exp(-0.5 * Math.pow((T - params.T_opt)/params.sigma_T, 2)); }
  function S_chla(C){ const lnC = Math.log(Math.max(C, 1e-6)); return Math.exp(-0.5*Math.pow((lnC-params.mu_c)/params.sigma_c,2)); }
  function S_tfg(F){ return 1 - Math.exp(-params.alpha_f * F); }
  function weightedGeoMean(parts, weights){
    let wsum=0, logSum=0, eps=1e-6;
    for(const k in parts){ const v=parts[k]; const w=weights[k]||0; if (v==null) continue; logSum += w*Math.log(Math.max(v,eps)); wsum+=w; }
    return wsum>0 ? Math.exp(logSum/wsum) : null;
  }
  function gridBBox(){ const b=map.getBounds(); return {s:b.getSouth(), n:b.getNorth(), w:b.getWest(), e:b.getEast()}; }

  // ------------------ Map init and layers (unchanged UI) ------------------
  let baseLayer, heatRisk, heatProb, map, markerDivIcon, restaurantsGroup;
  function initMap(){
    map = L.map('map', {worldCopyJump:true, preferCanvas:true, minZoom:2}).setView([23.7,90.4], 3);

    const gibsUrl = 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/wmts.cgi';
    baseLayer = L.tileLayer.wms(gibsUrl, { layers: 'MODIS_Terra_CorrectedReflectance_TrueColor', tileSize: 512, format: 'image/png', transparent: false, attribution: 'NASA GIBS' });
    baseLayer.on('tileerror', ()=>{ if (!baseLayer._fallbackDone){ baseLayer._fallbackDone=true; map.removeLayer(baseLayer); baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'© OSM contributors'}).addTo(map); }});
    baseLayer.addTo(map);

    heatRisk = L.heatLayer([], {radius: 22, blur: 18, maxZoom: 6, minOpacity: .45, gradient: {0.0:'rgba(46,204,113,0.0)', 0.35:'#2ECC71', 0.65:'#F1C40F', 1.0:'#E74C3C'}}).addTo(map);
    heatProb = L.heatLayer([], {radius: 22, blur: 18, maxZoom: 6, minOpacity: .45, gradient: {0.0:'#E74C3C', 0.5:'#F1C40F', 1.0:'#2ECC71'}});

    markerDivIcon = L.divIcon({className:'', html:'<div class="cross" role="img" aria-label="Selected location"></div>', iconSize:[18,18], iconAnchor:[9,9]});
    restaurantsGroup = L.layerGroup().addTo(map);

    map.on('click', (e)=>{
      state.selected = [e.latlng.lat, e.latlng.lng];
      updateURL();
      setMarker();
      analyzePoint();
      $('#simulateBtn').disabled = false;
      $('#locLabel').textContent = fmtLatLon(...state.selected);
    });

    $('#date').value = state.date;
    $('#timeSlider').value = state.offset;
    $('#timeLabel').textContent = labelForOffset(state.offset);

    setHeatMode(state.heatMode);
    setRestaurantsToggle(state.restaurantsOn);
    setDataMode(state.realData);

    refreshHeat();
    drawRestaurants();
    if (state.selected){ setMarker(); analyzePoint(); $('#simulateBtn').disabled = false; $('#locLabel').textContent = fmtLatLon(...state.selected); }

    map.on('moveend', refreshHeat);
  }

  let selMarker;
  function setMarker(){ if (selMarker) selMarker.remove(); selMarker = L.marker(state.selected, {icon: markerDivIcon, keyboard:false}).addTo(map); }

  function updateURL(){
    const u = new URL(location.href);
    u.searchParams.set('date', state.date);
    u.searchParams.set('mode', state.heatMode === 'prob' ? 'prob' : 'risk');
    u.searchParams.set('rest', state.restaurantsOn ? 'on':'off');
    u.searchParams.set('data', state.realData ? 'real':'mock');
    if (state.selected){ u.searchParams.set('lat', state.selected[0].toFixed(4)); u.searchParams.set('lon', state.selected[1].toFixed(4)); }
    history.replaceState(null, '', u.toString());
  }

  // ------------------ Real TCHI grid builder ------------------
  const cache = new Map();
  function cacheKey(kind,dateISO,bkey){ return `${kind}|${dateISO}|${bkey}`; }
  function bboxKey(b){ return `${b.s.toFixed(1)}_${b.n.toFixed(1)}_${b.w.toFixed(1)}_${b.e.toFixed(1)}`; }

  const DS_SST  = "jplMURSST41";     // Kelvin
  const DS_CHLA = "erdVHNchla8day";  // mg m^-3

  async function buildRealTchiGrid(){
    const bbox = gridBBox();
    const bkey = bboxKey(bbox);
    const step = 1;

    const sstK = cacheKey('sst', state.date, bkey);
    const chK  = cacheKey('chla', state.date, bkey);

    let sst = cache.get(sstK); if (!sst){ sst = await fetchGrid(DS_SST, 'analysed_sst', state.date, bbox, step); if (sst) cache.set(sstK, sst); }
    let ch  = cache.get(chK);  if (!ch){  ch  = await fetchGrid(DS_CHLA, 'chlorophyll', state.date, bbox, step); if (ch) cache.set(chK, ch); }

    if (!sst || !ch) return null;

    const sstC = {lats:sst.lats, lons:sst.lons, vals: sst.vals.map(row=>row.map(v=>v==null?null:kelvinToC(v)))};
    const grad = gradientMag(sstC);

    const n = sstC.lats.length, m = sstC.lons.length;
    const tchi = Array(n).fill(0).map(()=>Array(m).fill(null));
    for(let i=0;i<n;i++){
      for(let j=0;j<m;j++){
        const T = sstC.vals[i][j], C = ch.vals[i][j], F = grad.vals[i][j];
        if (T==null || C==null || F==null){ tchi[i][j]=null; continue; }
        const parts = { sst: S_sst(T), chla: S_chla(C), tfg: S_tfg(F) };
        tchi[i][j] = weightedGeoMean(parts, {sst:W.sst, chla:W.chla, tfg:W.tfg});
      }
    }
    return {lats: sstC.lats, lons: sstC.lons, tchi};
  }

  // ------------------ Mock field (fallback) ------------------
  const KNOWN_RESTS = [
    {lat:36.5, lon:-122.5, name:"Great White Bistro"},
    {lat:18.0, lon:  89.5, name:"Bengal Seal Buffet"},
    {lat:-34.0, lon: 18.5, name:"Cape Surf & Turf"},
    {lat:-31.0, lon:153.0, name:"Tasman Tuna Grill"}
  ];
  function dateIndexFromISO(s){ const epoch = new Date('2025-01-01T00:00:00Z'); return Math.round((parseISO(s)-epoch)/86400000); }
  function intensityBase(lat, lon, idx){ const rad=Math.PI/180; const latTerm=0.5+0.5*Math.cos((lat*rad)/1.2+idx*0.04); const lonTerm=0.5+0.5*Math.sin((lon*rad)/1.7-idx*0.03); const eddy=0.5+0.5*Math.sin((lat*rad*lon*rad)*0.2+idx*0.02); return clamp(0.35*latTerm+0.4*lonTerm+0.25*eddy,0,1); }
  function hotspotBoost(lat,lon){ let s=0; KNOWN_RESTS.forEach(h=>{ const d=Math.hypot((lat-h.lat)/8,(lon-h.lon)/8); s+=Math.exp(-d*d*1.2)*0.9; }); return clamp(s,0,1); }
  function mockFactors(lat,lon,idx){ const base=intensityBase(lat,lon,idx), boost=hotspotBoost(lat,lon), s=clamp(0.6*base+0.4*boost,0,1); return { sst:clamp(0.45+0.55*s-0.1*Math.sin(lat/15),0,1), chla:clamp(0.40+0.60*s+0.1*Math.cos(lon/20),0,1), tfg:clamp(0.25+0.90*s,0,1) }; }
  function tchiFromFactors(F){ const eps=1e-6; const logSum=(W.sst*Math.log(F.sst+eps))+(W.chla*Math.log(F.chla+eps))+(W.tfg*Math.log(F.tfg+eps)); const wsum=W.sst+W.chla+W.tfg; return clamp(Math.exp(logSum/wsum),0,1); }

  function generateMockHeatPoints(mode){
    const idx = dateIndexFromISO(state.date);
    const pts = [];
    const b = map.getBounds();
    const step = Math.max(1, Math.round((b.getNorth()-b.getSouth())/6));
    for(let lat = Math.floor(b.getSouth()); lat <= Math.ceil(b.getNorth()); lat += step){
      for(let lon = Math.floor(b.getWest()); lon <= Math.ceil(b.getEast()); lon += step){
        const tchi = tchiFromFactors(mockFactors(lat, lon, idx));
        const risk = 1 - tchi;
        const val = mode === 'prob' ? tchi : risk;
        if (val > 0.10) pts.push([lat, lon, val]);
      }
    }
    return pts;
  }

  // ------------------ Heat refresh ------------------
  async function refreshHeat(){
    if (state.realData){
      const grid = await buildRealTchiGrid();
      if (!grid){
        state.realData = false;
        setDataMode(false);
        console.warn("Real data unavailable; falling back to Mock.");
        refreshHeat();
        return;
      }
      const ptsProb = [], ptsRisk = [];
      const {lats,lons,tchi} = grid;
      for(let i=0;i<lats.length;i++){
        for(let j=0;j<lons.length;j++){
          const v = tchi[i][j]; if (v==null) continue;
          ptsProb.push([lats[i], lons[j], v]);
          ptsRisk.push([lats[i], lons[j], 1 - v]);
        }
      }
      heatProb.setLatLngs(ptsProb);
      heatRisk.setLatLngs(ptsRisk);
      setActiveHeatLayer();
    } else {
      const ptsProb = generateMockHeatPoints('prob');
      const ptsRisk = generateMockHeatPoints('risk');
      heatProb.setLatLngs(ptsProb);
      heatRisk.setLatLngs(ptsRisk);
      setActiveHeatLayer();
    }
  }

  function setActiveHeatLayer(){
    if (state.heatMode === 'prob'){
      if (map.hasLayer(heatRisk)) map.removeLayer(heatRisk);
      if (!map.hasLayer(heatProb)) heatProb.addTo(map);
      $('#legendTitle').textContent = "Shark probability (TCHI, %)";
      $('#legendLeft').textContent = "Low chance";
      $('#legendRight').textContent = "High chance";
      $('#legendGrad').style.background = 'linear-gradient(90deg, var(--bad), var(--mid), var(--good))';
      $('#modeRisk').setAttribute('aria-pressed','false');
      $('#modeProb').setAttribute('aria-pressed','true');
    } else {
      if (map.hasLayer(heatProb)) map.removeLayer(heatProb);
      if (!map.hasLayer(heatRisk)) heatRisk.addTo(map);
      $('#legendTitle').textContent = "SHSR (%) — lower is better";
      $('#legendLeft').textContent = "Low risk";
      $('#legendRight').textContent = "High risk";
      $('#legendGrad').style.background = 'linear-gradient(90deg, var(--good), var(--mid), var(--bad))';
      $('#modeRisk').setAttribute('aria-pressed','true');
      $('#modeProb').setAttribute('aria-pressed','false');
    }
  }
  function setHeatMode(mode){ state.heatMode = mode==='prob' ? 'prob' : 'risk'; setActiveHeatLayer(); updateURL(); }

  // ------------------ Restaurants ------------------
  let restaurantMarkers = [];
  const adj = ["Savage","Silent","Rogue","Apex","Midnight","Electric","Emerald","Silver","Turbo","Crimson"];
  const noun = ["Fin","Reef","Dorsal","Bite","Chomp","Current","Tide","Surge","Strike","Hunt"];
  function seededRand(seed){ let x = Math.abs(Math.floor(seed)) % 2147483647; return () => (x = (x * 48271) % 2147483647) / 2147483647; }
  function fancyName(lat, lon, idx){ const r = seededRand((lat*1000+lon*1000+idx*13)); return `${adj[Math.floor(r()*adj.length)]} ${noun[Math.floor(r()*noun.length)]} Grill`; }

  async function drawRestaurants(){
    restaurantsGroup.clearLayers(); restaurantMarkers = [];
    KNOWN_RESTS.forEach(k=>{
      const icon = L.divIcon({className:'', iconSize:[28,32], iconAnchor:[14,14], html:`<div class="fin"><span>🦈</span></div><div class="fin-label">${k.name}</div>`});
      const m = L.marker([k.lat, k.lon], {icon, keyboard:false}).addTo(restaurantsGroup);
      restaurantMarkers.push(m);
    });
    let candidates = [];
    if (state.realData){
      const grid = await buildRealTchiGrid();
      if (grid){
        const {lats,lons,tchi} = grid;
        for(let i=0;i<lats.length;i++) for(let j=0;j<lons.length;j++){ const v=tchi[i][j]; if (v!=null) candidates.push({lat:lats[i], lon:lons[j], p:v}); }
      }
    } else {
      const b = map.getBounds(); const step = Math.max(2, Math.round((b.getNorth()-b.getSouth())/6));
      const idx = dateIndexFromISO(state.date);
      for(let lat = Math.floor(b.getSouth()); lat <= Math.ceil(b.getNorth()); lat += step){
        for(let lon = Math.floor(b.getWest()); lon <= Math.ceil(b.getEast()); lon += step){
          const p = tchiFromFactors(mockFactors(lat, lon, idx));
          candidates.push({lat, lon, p});
        }
      }
    }
    candidates.sort((a,b)=>b.p-a.p);
    const top = candidates.slice(0,3);
    top.forEach(c=>{
      const name = fancyName(c.lat, c.lon, dateIndexFromISO(state.date));
      const icon = L.divIcon({className:'', iconSize:[28,32], iconAnchor:[14,14], html:`<div class="fin" style="background:rgba(46,204,113,.18);border-color:var(--good)"><span>⭐</span></div><div class="fin-label">${name}</div>`});
      const m = L.marker([c.lat, c.lon], {icon, keyboard:false}).addTo(restaurantsGroup);
      restaurantMarkers.push(m);
    });
    $('#restSummary').textContent = state.restaurantsOn ? `Restaurants: ${restaurantMarkers.length}` : '';
    if (!state.restaurantsOn) restaurantsGroup.remove(); else if (!map.hasLayer(restaurantsGroup)) restaurantsGroup.addTo(map);
  }
  function setRestaurantsToggle(on){
    state.restaurantsOn = !!on;
    $('#restaurantsBtn').setAttribute('aria-pressed', on ? 'true' : 'false');
    if (on) { if (!map.hasLayer(restaurantsGroup)) restaurantsGroup.addTo(map); drawRestaurants(); }
    else { restaurantsGroup.remove(); }
    updateURL();
  }

  // ------------------ Sidebar analysis ------------------
  let sparkChart;
  async function analyzePoint(){
    if (!state.selected) return;
    const [lat, lon] = state.selected;
    $('#locLabel').textContent = fmtLatLon(lat, lon);

    if (state.realData){
      const bbox = {s:lat-2,n:lat+2,w:lon-2,e:lon+2};
      const sst = await fetchGrid(DS_SST, 'analysed_sst', state.date, bbox, 0.5);
      const ch  = await fetchGrid(DS_CHLA,'chlorophyll', state.date, bbox, 0.5);
      if (sst && ch){
        const pickIdx = (arr, v) => arr.reduce((bi, a, i)=> Math.abs(a-v) < Math.abs(arr[bi]-v) ? i : bi, 0);
        const i = pickIdx(sst.lats, lat), j = pickIdx(sst.lons, lon);
        const T = sst.vals[i][j]==null?null:kelvinToC(sst.vals[i][j]);
        const C = ch.vals[i][j];
        let F=null;
        if (i>0&&j>0&&i<sst.lats.length-1&&j<sst.lons.length-1){
          const c3 = {lats:sst.lats.slice(i-1,i+2), lons:sst.lons.slice(j-1,j+2), vals: sst.vals.slice(i-1,i+2).map(r=>r.slice(j-1,j+2).map(v=>v==null?null:kelvinToC(v)))};
          F = gradientMag(c3).vals[1][1];
        }
        if (T!=null && C!=null && F!=null){
          const parts = { sst:S_sst(T), chla:S_chla(C), tfg:S_tfg(F) };
          const tchi = weightedGeoMean(parts, {sst:W.sst,chla:W.chla,tfg:W.tfg});
          const shsr = (1 - tchi) * 100;
          $('#tchiScore').textContent = `${Math.round(tchi*100)}/100`;
          $('#shsrScore').textContent = `${Math.round(shsr)}%`;
          renderFactors(parts);
        }
      }
    } else {
      const idx = dateIndexFromISO(state.date);
      const series = [];
      for (let d=-4; d<=2; d++){
        const di = idx + d;
        const isoDay = iso(addDays(parseISO(state.date), d));
        const f = mockFactors(lat, lon, di);
        series.push({date: isoDay, tchi: tchiFromFactors(f), factors: f});
      }
      const latest = series[4];
      const shsr = (1 - latest.tchi) * 100;
      $('#tchiScore').textContent = `${Math.round(latest.tchi*100)}/100`;
      $('#shsrScore').textContent = `${Math.round(shsr)}%`;
      renderFactors(latest.factors);
      renderSpark(series);
    }
  }

  function renderFactors(F){
    const order = [["SST","sst"],["Chl‑a","chla"],["TFG","tfg"]];
    const wrap = $('#factorBars'); wrap.innerHTML = "";
    order.forEach(([label,key])=>{
      const v = F[key]; const pct = Math.round((v ?? 0)*100);
      const row = document.createElement('div'); row.className='bar';
      row.innerHTML = `<div class="muted">${label}</div><div class="track"><div class="fill" style="width:${pct}%"></div></div><div>${pct}%</div>`;
      wrap.appendChild(row);
    });
  }

  function renderSpark(series){
    const ctx = $('#spark').getContext('2d');
    const labels = series.map(s=>s.date.slice(5));
    const vals = series.map(s=>+(s.tchi*100).toFixed(2));
    if (sparkChart){ sparkChart.destroy(); }
    sparkChart = new Chart(ctx, {
      type:'line',
      data:{ labels, datasets:[{ label:'TCHI (/100)', data:vals, borderColor:'#3BA3FF', backgroundColor:'rgba(59,163,255,.15)', tension:.25, fill:true, pointRadius:3 }]},
      options:{ responsive:true, plugins:{legend:{display:false}}, scales:{ y:{min:0,max:100,grid:{color:'rgba(255,255,255,.06)'}}, x:{grid:{display:false}} } }
    });
  }

  // ------------------ Date & Time Machine ------------------
  function setDateFromOffset(off){
    state.offset = clamp(off, minOffset, maxOffset);
    state.date = dateFromOffset(state.offset);
    $('#date').value = state.date; $('#timeSlider').value = state.offset; $('#timeLabel').textContent = labelForOffset(state.offset);
    updateURL(); refreshHeat(); drawRestaurants(); analyzePoint();
  }
  $('#date').addEventListener('change', (e)=>{
    const picked = e.target.value || todayISO;
    const offset = Math.round((parseISO(picked) - parseISO(todayISO))/86400000);
    setDateFromOffset(offset);
  });
  $('#timeSlider').addEventListener('input', (e)=> $('#timeLabel').textContent = labelForOffset(parseInt(e.target.value||'0',10)));
  $('#timeSlider').addEventListener('change', (e)=> setDateFromOffset(parseInt(e.target.value||'0',10)));
  $('#prevDay').addEventListener('click', ()=> setDateFromOffset(state.offset - 1));
  $('#nextDay').addEventListener('click', ()=> setDateFromOffset(state.offset + 1));
  document.addEventListener('keydown', (e)=>{ if (e.altKey && e.key==='ArrowLeft') $('#prevDay').click(); if (e.altKey && e.key==='ArrowRight') $('#nextDay').click(); if (e.key==='?') togglePop($('#infoPop')); });

  $('#play').addEventListener('click', ()=>{
    if (state.playTimer){ clearInterval(state.playTimer); state.playTimer=null; $('#play').textContent='Play'; return; }
    $('#play').textContent='Pause';
    state.playTimer = setInterval(()=>{
      let next = state.offset + 1;
      if (next > maxOffset) next = minOffset;
      setDateFromOffset(next);
    }, 1000);
  });

  // Heat mode toggles
  $('#modeRisk').addEventListener('click', ()=> setHeatMode('risk'));
  $('#modeProb').addEventListener('click', ()=> setHeatMode('prob'));

  // Restaurants toggle
  $('#restaurantsBtn').addEventListener('click', ()=> setRestaurantsToggle(!state.restaurantsOn));

  // Data mode toggle
  function setDataMode(on){
    state.realData = !!on;
    $('#dataModeBtn').setAttribute('aria-pressed', state.realData ? 'true':'false');
    $('#dataModeBtn').textContent = state.realData ? 'Data: Real' : 'Data: Mock';
    updateURL(); refreshHeat(); drawRestaurants(); analyzePoint();
  }
  $('#dataModeBtn').addEventListener('click', ()=> setDataMode(!state.realData));

  // ------------------ Info & Credits ------------------
  function togglePop(pop){ const open = pop.classList.toggle('open'); pop.setAttribute('aria-modal', open ? 'true' : 'false'); }
  $('#infoBtn').addEventListener('click', ()=>togglePop($('#infoPop')));
  $('#creditsBtn').addEventListener('click', ()=>togglePop($('#creditsPop')));
  document.addEventListener('click', (e)=>{ if (!$('#infoPop').contains(e.target) && e.target !== $('#infoBtn')) $('#infoPop').classList.remove('open');
                                            if (!$('#creditsPop').contains(e.target) && e.target !== $('#creditsBtn')) $('#creditsPop').classList.remove('open'); });

  // ------------------ Export PNG ------------------
  $('#exportBtn').addEventListener('click', async ()=>{
    const node = document.getElementById('app');
    const canvas = await html2canvas(node, {backgroundColor: null, scale: 2, useCORS: true});
    const link = document.createElement('a'); link.download = `sharkscope_${state.date}_${state.heatMode}_${state.realData?'real':'mock'}.png`;
    link.href = canvas.toDataURL('image/png'); link.click();
  });

  // ------------------ Simulation Modal ------------------
  const sim = { open:false, maps:{before:null, after:null}, circle:null };
  function openSim(){
    if (!state.selected) return;
    const [lat, lon] = state.selected;
    const idx = dateIndexFromISO(state.date);
    const F = mockFactors(lat, lon, idx);
    const prev = tchiFromFactors(F);
    const refined = clamp(prev + 0.14, 0, 1);
    $('#prevTchi').textContent = toFixed(prev,2);
    $('#refinedTchi').textContent = toFixed(refined,2);
    const dT = refined - prev, dS = -((1-refined) - (1-prev)) * 100;
    $('#deltaTchi').innerHTML = `<span class="${dT>=0?'pos':'neg'}">${dT>=0?'+':''}${toFixed(dT,2)}  /  ${dS>=0?'-':''}${Math.abs(dS).toFixed(0)}%</span>`;

    $('#simBackdrop').classList.add('open');
    document.body.style.overflow='hidden';
    document.body.classList.add('modal-open');
    initSimMaps(lat, lon);
    sim.open = true;
  }
  function initSimMaps(lat, lon){
    if (sim.maps.before){ sim.maps.before.remove(); sim.maps.after.remove(); sim.circle=null; }
    const opts = {worldCopyJump:true, preferCanvas:true, zoom:8, center:[lat,lon], attributionControl:false};
    const gibsUrl = 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/wmts.cgi';
    const makeBase = () => L.tileLayer.wms(gibsUrl, {layers:'MODIS_Terra_CorrectedReflectance_TrueColor', tileSize:512, format:'image/png'});

    sim.maps.before = L.map('mapBefore', opts);
    const bL = makeBase().addTo(sim.maps.before);
    const beforeHeat = (state.heatMode==='prob'? heatProb : heatRisk).getLatLngs?.() || [];
    L.heatLayer(beforeHeat, {radius:20, blur:16, maxZoom:6, minOpacity:.5, gradient: state.heatMode==='prob' ? {0.0:'#E74C3C',0.5:'#F1C40F',1.0:'#2ECC71'} : {0.0:'rgba(46,204,113,0.0)',0.35:'#2ECC71',0.65:'#F1C40F',1.0:'#E74C3C'}}).addTo(sim.maps.before);

    sim.maps.after = L.map('mapAfter', opts);
    const aL = makeBase().addTo(sim.maps.after);
    L.heatLayer(beforeHeat, {radius:20, blur:16, maxZoom:6, minOpacity:.5, gradient: state.heatMode==='prob' ? {0.0:'#E74C3C',0.5:'#F1C40F',1.0:'#2ECC71'} : {0.0:'rgba(46,204,113,0.0)',0.35:'#2ECC71',0.65:'#F1C40F',1.0:'#E74C3C'}}).addTo(sim.maps.after);
    sim.circle = L.circle([lat,lon], {radius:5000, color:'#2ECC71', weight:2, fillColor:'#2ECC71', fillOpacity:.25}).addTo(sim.maps.after);

    setTimeout(()=>{ sim.maps.before.invalidateSize(); sim.maps.after.invalidateSize(); }, 60);
    [bL, aL].forEach(layer=> layer.on('tileerror', ()=>{ const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'); layer.remove(); osm.addTo(layer._map); }));
  }
  $('#simulateBtn').addEventListener('click', openSim);
  $('#closeSim').addEventListener('click', ()=>{ $('#simBackdrop').classList.remove('open'); document.body.style.overflow=''; document.body.classList.remove('modal-open'); sim.open=false; });
  $('#rerunSim').addEventListener('click', openSim);
  $('#simBackdrop').addEventListener('click', (e)=>{ if (e.target.id==='simBackdrop') $('#closeSim').click(); });
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && sim.open) $('#closeSim').click(); });

  // ------------------ Boot ------------------
  window.addEventListener('load', ()=>{ initMap(); updateURL(); });
})();
</script>

<!-- Remove the extra ERDDAP helper script block you previously appended here -->
<style>
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</body>
</html>